-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/michaeljklein/monotonic-set-map#readme</a>
@package monotonic-set-map
@version 0.1.0.0

module Data.Word4

-- | <a>Word8</a> where the 4 most significant bits are zero.
newtype Word4
Word4 :: Word8 -> Word4
[unWord4] :: Word4 -> Word8
instance GHC.Show.Show Data.Word4.Word4
instance GHC.Classes.Ord Data.Word4.Word4
instance GHC.Classes.Eq Data.Word4.Word4
instance Test.QuickCheck.Arbitrary.Arbitrary Data.Word4.Word4

module Lib

-- | <tt>mapMonotonicallyInc</tt> can reduce the needed number of required
--   applications of the given function. For example, consider the
--   following case:
--   
--   <pre>
--   mapMonotonicallyInc :: Set a -&gt; Set ()
--   mapMonotonicallyInc (const ())
--   </pre>
--   
--   while <tt>S.map (const ())</tt> takes <tt>O(n log n)</tt> time, the
--   above takes the ideal: <tt>O(1)</tt> constant time.
--   
--   The following case also exhibits this behavior:
--   
--   <pre>
--   mapMonotonicallyInc ceiling $
--     fromDistinctAscList
--       [0.64, 0.75, 0.95]
--   </pre>
--   
--   Property that one is less than another, with <a>counterexample</a>
lt :: (Ord a, Show a) => a -> a -> Property

-- | Property that one is less than or equal to another, with
--   <a>counterexample</a>
leq :: (Ord a, Show a) => a -> a -> Property

-- | Property that the arguments are non-equal, with <a>counterexample</a>
(/==) :: (Eq a, Show a) => a -> a -> Property
infix 4 /==

-- | The <a>sum</a> of a set is not monotonically increasing:
--   
--   <pre>
--   fromList [1,4]
--   fromList [2]
--   5 &gt;  2
--   </pre>
sumNotMonoInc :: ()

-- | Apply the function repeatedly until it returns <a>Nothing</a>. Return
--   the last <a>Just</a> result or the input if there is none.
fixMaybeOn :: (a -> Maybe a) -> a -> a

-- | Recalculate the size given a root and its two immediate
--   sub-<a>Set</a>s
resize :: a -> Set a -> Set a -> Set a

-- | Recalculate the size a la <a>resize</a>, also given a constructor to
--   produce the result
resizeF :: (Int -> a -> Set a -> Set a -> b) -> a -> Set a -> Set a -> b

-- | If the root of the tree is equal to the root of the left subtree, then
--   so are the elements of the left subtree's right subtree. We join them
--   with their new sizes.
joinLeft :: Eq a => Set a -> Maybe (Set a)

-- | See <a>joinLeft</a>
joinRight :: Eq a => Set a -> Maybe (Set a)

-- | <a>joinRight</a> as many times as possible, then do the same with
--   <a>joinLeft</a>
firstJoins :: Eq a => Set a -> Set a

-- | Reimplementation of <a>firstJoins</a>
joinLrs :: Eq a => Set a -> Set a

-- | Join equal values along right sub-<a>Set</a>s
joinRights :: Eq a => Set a -> Set a

-- | <a>joinRights</a> on a known non-<a>Tip</a> <a>Set</a>
joinRightsLoop :: Eq a => a -> Set a -> Set a -> Set a

-- | Join equal elements
joins :: Eq a => Set a -> Set a

-- | <a>joins</a> on a known non-<a>Tip</a> <a>Set</a>
joinsF :: Eq a => a -> Set a -> Set a -> Set a

-- | <a>mapLevels</a> <a>firstJoins</a>
joins'' :: Eq a => Set a -> Set a

-- | <a>mapLevels</a> <a>joinLrs</a>
joins' :: Eq a => Set a -> Set a
mapLevels :: (Set a -> Set a) -> Set a -> Set a

-- | Using <a>joins</a>
mapMonotonicallyIncreasing :: Eq b => (a -> b) -> Set a -> Set b

-- | Using <a>joins'</a>
mapMonotonicallyIncreasing' :: Eq b => (a -> b) -> Set a -> Set b

-- | Using <a>joins''</a>
mapMonotonicallyIncreasing'' :: Eq b => (a -> b) -> Set a -> Set b

-- | Logical implication
impl :: Bool -> Bool -> Bool

-- | Get <a>Just</a> the first element of a <a>Set</a> and the rest of it
--   or <a>Nothing</a>
uncons :: Ord a => Set a -> Maybe (a, Set a)

-- | <a>mapMonotonicallyIncreasing</a> with duplicates removed is
--   equivalent to <a>map</a> for monotonically increasing functions
mapMonotonicHolds :: (Ord a, Ord b, Show a, Show b) => ((a -> b) -> Set a -> Set b) -> (a -> b) -> Set a -> Property

-- | <a>mapMonotonicHolds</a> where the first element of a <a>Set</a>
--   replaces all elements not in the first <a>Set</a> and the rest are
--   untouched.
mapMonotonicHoldsSubset :: (Ord a, Show a) => ((a -> a) -> Set a -> Set a) -> Set a -> Set a -> Property

-- | Infinite streams
newtype Stream a
Stream :: Cofree Identity a -> Stream a
[runStream] :: Stream a -> Cofree Identity a

-- | Keep in <a>Set</a> if <a>True</a>
subsetBy :: Ord a => Stream Bool -> Set a -> Set a

-- | Use <a>subsetBy</a> to provide the first argument
withSubset :: Ord a => (Set a -> Set a -> b) -> Stream Bool -> Set a -> b

-- | Subset-input properties
type SubsetProp a = Stream Bool -> Set a -> Property

-- | <a>mapMonotonicHoldsSubset</a> <a>mapMonotonicallyIncreasing</a> for
--   <a>Word4</a>
prop_mapMonotonicHoldsSubsetWord4 :: SubsetProp Word4

-- | <a>mapMonotonicHoldsSubset</a> <a>mapMonotonicallyIncreasing</a> for
--   <a>Word8</a>
prop_mapMonotonicHoldsSubsetWord8 :: SubsetProp Word8

-- | <a>mapMonotonicHoldsSubset</a> <a>mapMonotonicallyIncreasing'</a> for
--   <a>Word4</a>
prop_mapMonotonicHoldsSubsetWord4' :: SubsetProp Word4

-- | <a>mapMonotonicHoldsSubset</a> <a>mapMonotonicallyIncreasing'</a> for
--   <a>Word8</a>
prop_mapMonotonicHoldsSubsetWord8' :: SubsetProp Word8

-- | <a>mapMonotonicHoldsSubset</a> <a>mapMonotonicallyIncreasing''</a> for
--   <a>Word4</a>
prop_mapMonotonicHoldsSubsetWord4'' :: SubsetProp Word4

-- | <a>mapMonotonicHoldsSubset</a> <a>mapMonotonicallyIncreasing''</a> for
--   <a>Word8</a>
prop_mapMonotonicHoldsSubsetWord8'' :: SubsetProp Word8
countSubsetSums :: Int -> Int
countSubsetSums2 :: Int -> Int
countSubsetSums3 :: Int -> Int

-- | Set up bench environment with:
--   
--   <pre>
--   let small = [1..100]
--       large = [1..2^10]
--       halfOverlapping = S.mapMonotonic (x -&gt; if even x then x + 1 else x) [1..2^20]
--   return (small, large, halfOverlapping)
--   </pre>
setupEnv :: IO (Set Word8, Set Word16, Set Word32)

-- | Run benchmarks
runBenches :: IO ()

-- | Run all <tt>prop_</tt> tests
runTests :: IO Bool
instance GHC.Base.Functor Lib.Stream
instance GHC.Show.Show a => GHC.Show.Show (Lib.Stream a)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Lib.Stream a)
instance Data.Foldable.Foldable Lib.Stream
